---
title: " "
output:
  pdf_document:
    # citation_package: natbib
    # number_sections: TRUE
    # keep_tex: TRUE
bibliography: bib.bib
link-citations: TRUE
csl: Chicago.csl
geometry: "left  =  2cm, right  =  2cm, top  =  2.5cm, bottom  =  2.5cm"
fontsize: 12pt
header-includes:
  - \usepackage{enumitem}
  - \usepackage{float}
  - \usepackage{sectsty}
  - \usepackage{paralist}
  - \usepackage{setspace}\spacing{1.5}
  - \usepackage{fancyhdr}
  - \usepackage{lastpage}
  - \usepackage{dcolumn}
  - \usepackage{ragged2e}
  - \usepackage{graphicx}
  - \usepackage{amsmath}
  - \usepackage[nottoc, numbib]{tocbibind}
  - \usepackage{wrapfig}
  - \floatplacement{figure}{H}
fig_caption: true 
fig_crop: true
highlight: "tango"
linkcolor: blue
urlcolor: blue
citecolor: black
df_print: kable
---

```{r include = FALSE}
knitr::opts_chunk$set(
	echo  =  FALSE,
	include = FALSE,
	fig.show  =  TRUE,
	message  =  FALSE,
	warning  =  FALSE,
	fig.pos = 'H'
)
options(tinytex.verbose = TRUE)
```

```{r Function that enables individualized boxplots}
IndividualizedBoxplotQuantiles <- function(x) {
  r <- quantile(x, probs = c(0.05, 0.25, 0.5, 0.75, 0.95))
  names(r) <- c("ymin", "lower", "middle", "upper", "ymax")
  r
}

DefinitionOfOutliers = function(x) 
  {
  subset(x, quantile(x,0.95) < x)
  }
```

```{r}
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk  =  function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size  !=   "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})
```

```{r}
pacman::p_load(devtools, pacman, ggplot2, tidyverse, GADMTools, ggmap, cowplot, car,
               sp, spacetime, gstat, maps, mapdata, 
               pryr, animation, lineprof, gganimate)
```

<style>
body {
text-align: justify}
</style>

\allsectionsfont{\centering}
\subsectionfont{\centering}
\subsubsectionfont{\justifying}

\pagenumbering{gobble}

\begin{FlushRight}

\vspace{0cm}

```{r uni_logo, out.width = "50%", include = TRUE}
knitr::include_graphics("LogoUni.png")
```

\end{FlushRight}

\begin{centering}

\vspace{4,5cm}

\Large

\doublespacing
{\bf MODELING EXTREME PRECIPITATION EVENTS\\A THESIS PAPER FOR THE DEGREE OF \\BACHELOR OF SCIENCE} 
\singlespacing

{\ Wintersemester 2022}

\normalsize
\singlespacing

By

\Large
\singlespacing
{\ Ekin Gülhan}

\end{centering}

\begin{FlushLeft}

\vspace{3,5cm}

\Large
\singlespacing
\normalsize
Supervisor: Dr. Isa Marques \\Enrolment number: 21675680 \\e-mail: ekin.guelhan(at)stud.uni-goettingen.de \\Address: Hannoversche Straße 134, 37077 Göttingen \\Date: `r Sys.Date()` 

\end{FlushLeft}

\newpage 

\centering
\raggedright
\hypersetup{linkcolor = black}
\tableofcontents

\newcounter{savepage}
\cleardoublepage
\pagenumbering{Roman}

\newpage

\cleardoublepage
\setcounter{savepage}{\arabic{page}}
\pagenumbering{arabic}

```{r}
options(scipen = 999, OutDec  =  ",")
```

\justifying

# Miscellaneous code 

```{r}
# getwd()

# Load the data
load("WeatherGermany.rda")

# Rename data 
WeatherDataDailyResolution = WeatherGermany 
rm(WeatherGermany)

# Filter the data temporally to observations made between 1976 and 2016
WeatherDataDailyResolution = filter(WeatherDataDailyResolution, year %in% 1996:(max(WeatherDataDailyResolution$year)))

# Create a list of all weather stations
ListOfAllWeatherStations = data.frame("Names of weather stations" = unique(WeatherDataDailyResolution$name))

# reformat the id column as numeric values
# WeatherDataDailyResolution$id = as.numeric(WeatherDataDailyResolution$id)
# reformat the id column as numeric values
# WeatherDataDailyResolution$id = as.numeric(WeatherDataDailyResolution$id)
# Create a list of all unique ids of the german weather stations
# ListOfAllUniqueIDs = data.frame(unique(data.frame(WeatherDataDailyResolution$id)))

# Create a list of unique pairs of angular coordinates, where each pair represents a weather station 
ListOfAllUniqueCoordinates = data.frame(unique(data.frame(WeatherDataDailyResolution$lon,WeatherDataDailyResolution$lat)))

# Change the name of the columns of the list of unique pairs of coordinates
colnames(ListOfAllUniqueCoordinates) = c("longitude","latitude")

# Change format of the index column to factor/categorical
WeatherDataDailyResolution$index = as.numeric(factor(WeatherDataDailyResolution$name))

# Create a list with all the unique index numbers
ListOfAllUniqueIndexnumbers = data.frame("IndexNumbers" = unique(WeatherDataDailyResolution$index))

# Relocate the index column before the id column 
WeatherDataDailyResolution = WeatherDataDailyResolution %>% relocate(index,.before = id)

# Order the Data based the values of the name column in an increasing way
WeatherDataDailyResolution = WeatherDataDailyResolution[order(WeatherDataDailyResolution$name),]

# Delete the id column, as the index column is a better substitute for it 
WeatherDataDailyResolution = subset(WeatherDataDailyResolution, select = -c(id) )

# Substitute all values "-999" as NAs, since this number is indeed code for not available
WeatherDataDailyResolution = WeatherDataDailyResolution %>%
   mutate(across(where(is.numeric), ~na_if(., -999)))

# Count the number of observations of daily resolution each weather station made
NumberOfObservationsPerWeatherStation = data.frame(count(WeatherDataDailyResolution, index))

# Compute the latest year of observation among all the weather stations
MaximumYear = max(WeatherDataDailyResolution$year, na.rm = TRUE)

# Compute the earliest year of observation among all the weather stations
MinimumYear = min(WeatherDataDailyResolution$year, na.rm = TRUE)

# Compute the spatial coverage among all the weather stations
RangeOfTemporalCoverage = MaximumYear - MinimumYear

# Compute the empirical distribution of the number of observations, meaning the 4 quartiles 
{
DistributionNumberOfObservations = summary(NumberOfObservationsPerWeatherStation$n)
}

# Compute the boundaries for the classification of an PE as an EPE in terms of the 5th and 95th percentile of precipitation height
{
ExtremePrecipitationClassificationBoundariesDailyResolution = data.frame("ClassificationBoundaries"= quantile(WeatherDataDailyResolution$rain,probs = c(0.05,0.95),na.rm = TRUE))
}

# Create a new variable that indicates the occurence of an EPE based on the arbitrary boundaries from above and the data on precipitation heigt
{
WeatherDataDailyResolution = 
  WeatherDataDailyResolution %>% mutate(ExtremePrecipitationEvent = 
                              case_when(WeatherDataDailyResolution$rain >= ExtremePrecipitationClassificationBoundariesDailyResolution[2,1]  ~ 1,
                                        WeatherDataDailyResolution$rain >= ExtremePrecipitationClassificationBoundariesDailyResolution[1,1] & WeatherDataDailyResolution$rain < ExtremePrecipitationClassificationBoundariesDailyResolution[2,1] ~ 0))
}

# Create a table that recounts that contrasts the number of observations of a weather stations with its' index number
NumberOfObservationsPerWeatherStation = data.frame(count(WeatherDataDailyResolution, index))

# Create an ordered list of unique altitude levels 
ListOfUniqueElevationLevels = data.frame("UniqueAltitudeLevels" = unique(WeatherDataDailyResolution$alt))
ListOfUniqueElevationLevels = data.frame("UniqueAltitudeLevels" = ListOfUniqueElevationLevels[order(ListOfUniqueElevationLevels$UniqueAltitudeLevels),])

# Construct a calendardate column
WeatherDataDailyResolution$CalendarDate = paste0(WeatherDataDailyResolution$year,
                                                 "-",
                                                 WeatherDataDailyResolution$month,
                                                 "-",
                                                 WeatherDataDailyResolution$day) 

# Change type of calendardate column from character to date format
WeatherDataDailyResolution$CalendarDate = as.Date(WeatherDataDailyResolution$CalendarDate)

# Create a column whose values depict the number of continuous days elapsed since 1st of January 4713 BC (Begin of Julian Periode)
WeatherDataDailyResolution$JulianDate = insol::JD(as.POSIXlt(WeatherDataDailyResolution$CalendarDate))

# Create a column whose values depict the number of continuous days elapsed since the 1st of January 1936 (earliest time of observation in the present metereological data)
WeatherDataDailyResolution$ContinuousDaysElapsedSinceEarliestObservation = 
  round(insol::JD(as.POSIXlt(WeatherDataDailyResolution$CalendarDate))-insol::JDymd(1996,1,1,0,0),0)

# Create a column that indicates the metereological season an observation belongs to 
WeatherDataDailyResolution = WeatherDataDailyResolution %>% 
  mutate("Season" = case_when(
             WeatherDataDailyResolution$month <=  2 | WeatherDataDailyResolution$month ==  12 ~ "Winter",
             WeatherDataDailyResolution$month <=  11 & WeatherDataDailyResolution$month >=  9 ~ "Autumn",
             WeatherDataDailyResolution$month <=  8 & WeatherDataDailyResolution$month >=  6 ~ "Summer",
             WeatherDataDailyResolution$month <=  5 & WeatherDataDailyResolution$month >=  3 ~ "Spring"))


# Create a data frame of class "spacetime: STIDF (Space Time Irregular Data Frame)"
WeatherDataDailyResolutionSpaceTime = stConstruct(x = WeatherDataDailyResolution,
                                        space = c("lon","lat"),
                                        time = "CalendarDate")

```

# Transform the precipitation data to different temporal resolutions

```{r}
# Transformation of the WeatherData from daily to monthly resolution (summing up daily total precipitation)
WeatherDataMonthlyResolution = data.frame(
  aggregate( #Compute some sort of aggregate values
    WeatherDataDailyResolution[,c("rain","sun")], #data, that is to be aggregate
    by = list #list of columns, on whose values the aggregation shall be based
    (
      WeatherDataDailyResolution$index, #First criterion of aggregation
      WeatherDataDailyResolution$year, #Second criterion of aggregation
      WeatherDataDailyResolution$month #Third criterion of aggregation
      #All the observations within the same month within the same year characterizing the same weather station are aggregated  
    ), 
    FUN = sum) #aggregation is defined as computing the sum of daily values
)

# Rename the columns of the dataframe of monthly resolution data
colnames(WeatherDataMonthlyResolution) = c("IndexnumberOfWeatherStation","Year","Month","PrecipitationHeightInMillimetre","TotalHoursOfSunlight")

# Order the columns first by indexnumber, then by year and finally based on the month
WeatherDataMonthlyResolution = WeatherDataMonthlyResolution[order(WeatherDataMonthlyResolution$`IndexnumberOfWeatherStation`, 
                                                                  WeatherDataMonthlyResolution$Year,
                                                                  WeatherDataMonthlyResolution$Month),]

# Transformation of the WeatherData from daily to annual resolution (summing up total precipitation)
WeatherDataAnnualResolution = data.frame(
  aggregate( #Compute some sort of aggregate values
    WeatherDataDailyResolution[,c("rain","sun")], #data, that is to be aggregate
    by = list #list of columns, on whose values the aggregation shall be based
    (
      WeatherDataDailyResolution$index, #First criterion of aggregation
      WeatherDataDailyResolution$year #Second criterion of aggregation
      #All the values of a specific pair of A-value und B-values get aggregated
    ), 
    FUN = sum) #aggregation is defined as computing the sum of monthly values
)

# Rename the columns of the dataframe of annual resolution data
colnames(WeatherDataAnnualResolution) = c("IndexnumberOfWeatherStation","Year",
                                          "AnnualPrecipitationHeightInMillimetre", 
                                          "AnnualTotalHoursOfSunlight")

# Order the columns first by indexnumber, then by year
WeatherDataAnnualResolution = WeatherDataAnnualResolution[order(WeatherDataAnnualResolution$`IndexnumberOfWeatherStation`, 
                                                                  WeatherDataAnnualResolution$Year),]
# Delete rownames
rownames(WeatherDataDailyResolution) = NULL
rownames(WeatherDataMonthlyResolution) = NULL
rownames(WeatherDataAnnualResolution) = NULL

```

# Extract extreme values for different temporal resolutions 

```{r}
# Daily Temporal Resolution
{
# Compute the 95th percentile of the daily resolution weather data
ExtremePrecipitationClassificationBoundariesDailyResolution = data.frame("ClassificationBoundaries"= quantile(WeatherDataDailyResolution$rain,probs = c(0.05,0.95),na.rm = TRUE))

# Extract the extreme precipitation events / extreme precipitation heights based on the 95th percentile as threshold
ExtremePrecipitationHeightsDailyResolution = data.frame("ExtremePrecipitationHeights" = 
                                                          filter(.data = WeatherDataDailyResolution,
                                                                 rain >= ExtremePrecipitationClassificationBoundariesDailyResolution[2,1])) # Only Extreme Precipitation Heights
}

# Monthly Temporal Resolution
{
# Compute the 95th percentile of the monthly resolution weather data
ExtremePrecipitationClassificationBoundariesMonthlyResolution = data.frame("ClassificationBoundaries"= quantile(WeatherDataMonthlyResolution$`PrecipitationHeightInMillimetre`,
                                                                                                                probs = c(0.05,0.95),na.rm = TRUE))

# Extract the extreme precipitation events / extreme precipitation heights based on the 95th percentile as threshold
ExtremePrecipitationHeightsMonthlyResolution = data.frame("ExtremePrecipitationHeights" = 
                                           filter(.data = WeatherDataMonthlyResolution,
                                                  PrecipitationHeightInMillimetre >= ExtremePrecipitationClassificationBoundariesMonthlyResolution[2,1])) # Only Extreme Precipitation Heights
}

# Annual Temporal Resolution
{
# Compute the 95th percentile of the annual resolution weather data 
ExtremePrecipitationClassificationBoundariesAnnualResolution = data.frame("ClassificationBoundaries"= quantile(WeatherDataAnnualResolution$AnnualPrecipitationHeightInMillimetre,
                                                                                                               probs = c(0.05,0.95),na.rm = TRUE))

# Extract the extreme precipitation events / extreme precipitation heights based on the 95th percentile as threshold
ExtremePrecipitationHeightsAnnualResolution = data.frame("ExtremePrecipitationHeights" = filter(.data = WeatherDataAnnualResolution,
                                                                                                AnnualPrecipitationHeightInMillimetre >= ExtremePrecipitationClassificationBoundariesAnnualResolution[2,1])) # Only Extreme Precipitation Heights
}

```

```{r}
save.image()
```


\newpage

# Session Info

```{r}
#sessionInfo()
```

\newpage
